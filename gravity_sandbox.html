<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Flow - Gravity Sandbox</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050510;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: rgba(255, 255, 255, 0.8);
            user-select: none;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 300;
            letter-spacing: 0.1em;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.5);
            color: #d0e0ff;
        }

        p {
            margin: 5px 0 0;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .controls {
            margin-top: 15px;
            pointer-events: auto;
        }

        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            backdrop-filter: blur(4px);
        }

        button:hover {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }
    </style>
</head>

<body>

    <div id="ui-layer">
        <h1>COSMIC FLOW</h1>
        <p>Drag: Launch Star | Right-Drag: Pan | Wheel: Zoom</p>
        <div class="controls">
            <button id="resetBtn">Reset Cosmos</button>
        </div>
    </div>

    <canvas id="cosmos"></canvas>

    <script>
        /* =========================================
           CONFIG & STATE
           ========================================= */
        const CONFIG = {
            G: 0.1,                // Gravity constant
            FRICTION: 0.999,       // Minimal air resistance
            TRAIL_FADE: 0.15,      // Trail opacity
            MIN_MASS: 2,
            MAX_MASS: 25,
            BLACK_HOLE_MASS: 50,   // Threshold for becoming a Black Hole
            SUPERNOVA_MASS: 150,   // Threshold for explosion (Rebirth)
            DENSITY: 0.6,          // Radius = (mass/density)^0.5
            LAUNCH_POWER: 0.05,    // Launch velocity multiplier
            COLORS: [
                '#a0c4ff', '#b9fbc0', '#fbf8cc', '#ffcfd2', '#f1c0e8', '#cfbaf0', '#90dbf4'
            ]
        };

        const canvas = document.getElementById('cosmos');
        const ctx = canvas.getContext('2d', { alpha: false });

        let width, height;
        let stars = [];
        let particles = [];
        let isPaused = false;
        let flashIntensity = 0; // Screen flash for Supernova

        // Viewport transformation
        const view = {
            x: 0,
            y: 0,
            scale: 1.0,
            targetScale: 1.0
        };

        // User Input State
        const mouse = {
            x: 0, y: 0,           // Current screen pos
            startX: 0, startY: 0, // Drag start screen pos
            isDraggingLeft: false,
            isDraggingRight: false,
            dragStartTime: 0
        };

        /* =========================================
           INIT & RESIZE
           ========================================= */
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            // Fill background initially
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, width, height);
        }
        window.addEventListener('resize', resize);
        resize();

        function reset() {
            stars = [];
            particles = [];
            view.x = 0;
            view.y = 0;
            view.targetScale = 1.0;
            flashIntensity = 0;
        }
        document.getElementById('resetBtn').addEventListener('click', reset);

        /* =========================================
           CLASSES
           ========================================= */
        class Star {
            constructor(x, y, vx, vy, mass) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.mass = mass;
                this.updateProperties();
                if (this.isBlackHole) {
                    this.color = '#000000'; // Black core
                    this.glowColor = '#330066'; // Dark purple Accretion disk
                } else {
                    this.color = CONFIG.COLORS[Math.floor(Math.random() * CONFIG.COLORS.length)];
                }
            }

            updateProperties() {
                this.isBlackHole = this.mass >= CONFIG.BLACK_HOLE_MASS;
                // Black holes are denser
                this.radius = Math.sqrt(this.mass / (this.isBlackHole ? CONFIG.DENSITY * 3 : CONFIG.DENSITY));
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                if (this.isBlackHole) {
                    // Pulsating Accretion Disk
                    let pulse = 1.0 + Math.sin(Date.now() * 0.005) * 0.1;
                    ctx.shadowBlur = this.radius * 4 * pulse;
                    ctx.shadowColor = 'rgba(120, 50, 255, 0.8)';

                    // Draw Event Horizon (Black)
                    ctx.fillStyle = '#000';
                    ctx.fill();

                    // Draw Outline
                    ctx.strokeStyle = 'rgba(200, 100, 255, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else {
                    ctx.fillStyle = this.color;
                    ctx.shadowBlur = this.radius * 2;
                    ctx.shadowColor = this.color;
                    ctx.fill();
                }

                ctx.shadowBlur = 0; // Reset
            }
        }

        class Particle {
            constructor(x, y, color, isSucked = false, target = null) {
                this.x = x;
                this.y = y;
                this.color = color;

                if (isSucked && target) {
                    this.isSucked = true;
                    this.target = target;
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = (Math.random() - 0.5) * 2;
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 3; // Slightly faster for explosion
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                }

                this.life = 1.0;
                this.decay = 0.01 + Math.random() * 0.03;
            }

            update() {
                if (this.isSucked && this.target) {
                    // Accelerate towards black hole
                    let dx = this.target.x - this.x;
                    let dy = this.target.y - this.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);

                    this.vx += dx * 0.05;
                    this.vy += dy * 0.05;
                    this.x += this.vx;
                    this.y += this.vy;

                    // Fade faster when close
                    if (dist < this.target.radius) {
                        this.life = 0;
                    }
                } else {
                    this.x += this.vx;
                    this.y += this.vy;
                }
                this.life -= this.decay;
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, 2, 2);
                ctx.globalAlpha = 1.0;
            }
        }

        /* =========================================
           PHYSICS
           ========================================= */
        function updatePhysics() {
            // Check for Supernova
            for (let i = stars.length - 1; i >= 0; i--) {
                if (stars[i].mass >= CONFIG.SUPERNOVA_MASS) {
                    triggerSupernova(i);
                    // Star is removed in function, continue loop safely
                    continue;
                }
            }

            // N-body integration
            for (let i = 0; i < stars.length; i++) {
                let s1 = stars[i];
                for (let j = i + 1; j < stars.length; j++) {
                    let s2 = stars[j];

                    let dx = s2.x - s1.x;
                    let dy = s2.y - s1.y;
                    let distSq = dx * dx + dy * dy;
                    let dist = Math.sqrt(distSq);

                    // Collision Logic
                    if (dist < s1.radius + s2.radius) {
                        // Check Black Hole Interaction
                        if (s1.isBlackHole || s2.isBlackHole) {
                            consumeStar(i, j); // Black Hole eats Star (or smaller BH)
                        } else {
                            mergeStars(i, j); // Normal merge
                        }
                        j--; // Adjustment
                        continue;
                    }

                    // Gravity Force
                    if (dist > 5) {
                        let force = (CONFIG.G * s1.mass * s2.mass) / distSq;
                        let ax = force * (dx / dist);
                        let ay = force * (dy / dist);

                        s1.vx += ax / s1.mass;
                        s1.vy += ay / s1.mass;
                        s2.vx -= ax / s2.mass;
                        s2.vy -= ay / s2.mass;
                    }
                }
            }

            // Update positions
            for (let s of stars) {
                s.update();
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (particles[i].life <= 0) particles.splice(i, 1);
            }
        }

        function triggerSupernova(index) {
            let star = stars[index];

            // 1. Screen Flash
            flashIntensity = 1.0;

            // 2. Explosion Particles
            for (let k = 0; k < 100; k++) {
                particles.push(new Particle(star.x, star.y, '#ffffff'));
                particles.push(new Particle(star.x, star.y, '#aaaaff'));
            }

            // 3. Rebirth (Scatter small stars)
            let newStarsCount = 8 + Math.floor(Math.random() * 5);
            for (let k = 0; k < newStarsCount; k++) {
                let angle = (Math.PI * 2 * k) / newStarsCount;
                let speed = 2 + Math.random() * 3;

                let vx = Math.cos(angle) * speed + star.vx * 0.5; // Inherit some momentum
                let vy = Math.sin(angle) * speed + star.vy * 0.5;
                let mass = CONFIG.MIN_MASS + Math.random() * 5; // Small new stars

                stars.push(new Star(star.x + Math.cos(angle) * star.radius * 2, star.y + Math.sin(angle) * star.radius * 2, vx, vy, mass));
            }

            // Remove the Black Hole
            stars.splice(index, 1);

            // Console log for fun
            console.log("SUPERNOVA!");
        }

        // Logic when a Black Hole is involved
        function consumeStar(i, j) {
            let s1 = stars[i];
            let s2 = stars[j];

            // Determine predator and prey
            let predator, prey;

            // If both are BH, larger one eats smaller
            if (s1.isBlackHole && s2.isBlackHole) {
                if (s1.mass >= s2.mass) { predator = s1; prey = s2; }
                else { predator = s2; prey = s1; }
            }
            // If only one is BH
            else if (s1.isBlackHole) { predator = s1; prey = s2; }
            else { predator = s2; prey = s1; }

            // Predator grows
            predator.mass += prey.mass;

            // Conservation of momentum (Predator absorbs prey's momentum slightly)
            // But BH are heavy, so velocity change is small
            let totalMass = predator.mass; // Already added prey mass
            // Current momentum of predator before adding prey mass was (predator.mass - prey.mass) * v
            // This is simplified: just blend velocities based on mass ratio
            // V_new = (M_pred_old * V_pred + M_prey * V_prey) / M_new
            let m_old = predator.mass - prey.mass;
            predator.vx = (m_old * predator.vx + prey.mass * prey.vx) / predator.mass;
            predator.vy = (m_old * predator.vy + prey.mass * prey.vy) / predator.mass;

            // Update radius/type
            predator.updateProperties();

            // Sucking particles effect
            for (let k = 0; k < 15; k++) {
                // Particles start at prey position, get sucked into predator
                particles.push(new Particle(
                    prey.x + (Math.random() - 0.5) * prey.radius,
                    prey.y + (Math.random() - 0.5) * prey.radius,
                    prey.color,
                    true,
                    predator
                ));
            }

            // Remove prey
            // We need to find the correct index to splice
            // i and j are original indices.
            // If s1 is prey, remove i. If s2 is prey, remove j.
            if (prey === s1) stars.splice(i, 1);
            else stars.splice(j, 1);
        }

        // Logic for normal stars
        function mergeStars(i, j) {
            let s1 = stars[i];
            let s2 = stars[j];

            let totalMass = s1.mass + s2.mass;
            let newVx = (s1.mass * s1.vx + s2.mass * s2.vx) / totalMass;
            let newVy = (s1.mass * s1.vy + s2.mass * s2.vy) / totalMass;

            let newX = (s1.x * s1.mass + s2.x * s2.mass) / totalMass;
            let newY = (s1.y * s1.mass + s2.y * s2.mass) / totalMass;

            // Remove old stars
            stars.splice(Math.max(i, j), 1);
            stars.splice(Math.min(i, j), 1);

            let newStar = new Star(newX, newY, newVx, newVy, totalMass);
            stars.push(newStar);

            // Explosion effect
            for (let k = 0; k < 8; k++) {
                particles.push(new Particle(newX, newY, newStar.color));
            }
        }

        /* =========================================
           RENDERING
           ========================================= */
        function screenToWorld(sx, sy) {
            let centeredX = sx - width / 2;
            let centeredY = sy - height / 2;
            return {
                x: (centeredX / view.scale) - view.x,
                y: (centeredY / view.scale) - view.y
            };
        }

        function render() {
            // Smooth zoom interpolation
            view.scale += (view.targetScale - view.scale) * 0.1;

            // BACKGROUND with distortion hint for Black Holes?
            // Simple approach: Clear with trail fade
            ctx.fillStyle = `rgba(5, 5, 16, ${CONFIG.TRAIL_FADE})`;
            ctx.fillRect(0, 0, width, height);

            ctx.save();

            // Apply Camera Transform
            ctx.translate(width / 2, height / 2);
            ctx.scale(view.scale, view.scale);
            ctx.translate(view.x, view.y);

            // Draw Black Holes Layer First? No, standard Z-order (draw loop) is fine for 2D.
            // Just iterate.
            for (let s of stars) s.draw(ctx);
            for (let p of particles) p.draw(ctx);

            // Draw Launch Prediction
            if (mouse.isDraggingLeft) {
                let startWorld = screenToWorld(mouse.startX, mouse.startY);
                let currentWorld = screenToWorld(mouse.x, mouse.y);

                // Prediction Line
                ctx.beginPath();
                ctx.moveTo(startWorld.x, startWorld.y);
                ctx.lineTo(currentWorld.x, currentWorld.y);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.setLineDash([5, 5]);
                ctx.stroke();

                // Vector
                let dx = mouse.startX - mouse.x;
                let dy = mouse.startY - mouse.y;
                let vecX = dx * CONFIG.LAUNCH_POWER * 20;
                let vecY = dy * CONFIG.LAUNCH_POWER * 20;

                ctx.beginPath();
                ctx.moveTo(startWorld.x, startWorld.y);
                ctx.lineTo(startWorld.x + vecX / view.scale, startWorld.y + vecY / view.scale);
                ctx.strokeStyle = 'rgba(100, 255, 150, 0.8)';
                ctx.setLineDash([]);
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.lineWidth = 1;

                // Preview Mass
                let duration = (Date.now() - mouse.dragStartTime) / 1000;
                let massRatio = Math.min(duration / 2, 1);
                let mass = CONFIG.MIN_MASS + (CONFIG.MAX_MASS - CONFIG.MIN_MASS) * massRatio;
                let isBH = mass >= CONFIG.BLACK_HOLE_MASS; // User can't create BH directly usually unless MAX_MASS > BH_MASS
                // But let's keep visual consistent
                let previewRadius = Math.sqrt(mass / CONFIG.DENSITY);

                ctx.beginPath();
                ctx.arc(startWorld.x, startWorld.y, previewRadius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.stroke();
            }

            ctx.restore();

            // Screen Flash for Supernova
            if (flashIntensity > 0.01) {
                ctx.fillStyle = `rgba(255, 255, 255, ${flashIntensity})`;
                ctx.fillRect(0, 0, width, height);
                flashIntensity *= 0.90; // Fade out
            } else {
                flashIntensity = 0;
            }

            updatePhysics();
            requestAnimationFrame(render);
        }

        /* =========================================
           INPUT HANDLING
           ========================================= */
        canvas.addEventListener('mousedown', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;

            if (e.button === 0) { // Left Click
                mouse.isDraggingLeft = true;
                mouse.startX = e.clientX;
                mouse.startY = e.clientY;
                mouse.dragStartTime = Date.now();
            }
            else if (e.button === 2) { // Right Click
                mouse.isDraggingRight = true;
                mouse.startX = e.clientX;
                mouse.startY = e.clientY;
            }
        });

        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;

            if (mouse.isDraggingRight) {
                let dx = e.clientX - mouse.startX;
                let dy = e.clientY - mouse.startY;
                view.x += dx / view.scale;
                view.y += dy / view.scale;
                mouse.startX = e.clientX;
                mouse.startY = e.clientY;
            }
        });

        window.addEventListener('mouseup', e => {
            if (mouse.isDraggingLeft && e.button === 0) {
                let dx = mouse.startX - e.clientX;
                let dy = mouse.startY - e.clientY;

                let duration = (Date.now() - mouse.dragStartTime) / 1000;
                let massRatio = Math.min(duration / 2, 1.0);
                let mass = CONFIG.MIN_MASS + (CONFIG.MAX_MASS - CONFIG.MIN_MASS) * massRatio;

                let worldPos = screenToWorld(mouse.startX, mouse.startY);

                let vx = dx * CONFIG.LAUNCH_POWER / view.scale;
                let vy = dy * CONFIG.LAUNCH_POWER / view.scale;

                stars.push(new Star(worldPos.x, worldPos.y, vx, vy, mass));

                mouse.isDraggingLeft = false;
            }
            if (e.button === 2) {
                mouse.isDraggingRight = false;
            }
        });

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            const zoomSensitivity = 0.001;
            view.targetScale -= e.deltaY * zoomSensitivity * view.targetScale;
            view.targetScale = Math.max(0.1, Math.min(view.targetScale, 10.0));
        }, { passive: false });

        canvas.addEventListener('contextmenu', e => e.preventDefault());

        /* =========================================
           START
           ========================================= */
        // Create initial scenario: One normal star and one near-BH threshold star to test evolution easily?
        // Let's just do standard random
        for (let i = 0; i < 5; i++) {
            stars.push(new Star(
                (Math.random() - 0.5) * 300,
                (Math.random() - 0.5) * 300,
                (Math.random() - 0.5) * 1,
                (Math.random() - 0.5) * 1,
                Math.random() * 10 + 5
            ));
        }

        render();

    </script>
</body>

</html>