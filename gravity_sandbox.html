<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Flow - Gravity Sandbox</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050510;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: rgba(255, 255, 255, 0.8);
            user-select: none;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 300;
            letter-spacing: 0.1em;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.5);
            color: #d0e0ff;
        }

        p {
            margin: 5px 0 0;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .controls {
            margin-top: 15px;
            pointer-events: auto;
        }

        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            backdrop-filter: blur(4px);
        }

        button:hover {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }
    </style>
</head>

<body>

    <div id="ui-layer">
        <h1>COSMIC FLOW</h1>
        <p>Drag: Hold to create (Short=Asteroid, Med=Planet, Long=Star) | Right-Drag: Pan | Wheel: Zoom</p>
        <div class="controls">
            <button id="resetBtn">Reset Cosmos</button>
            <button id="galaxyBtn">Spawn Galaxy</button>
        </div>
    </div>

    <canvas id="cosmos"></canvas>

    <script>
        /* =========================================
           CONFIG & STATE
           ========================================= */
        const CONFIG = {
            G: 0.1,                // Gravity constant
            FRICTION: 0.999,       // Minimal air resistance
            TRAIL_FADE: 0.15,      // Trail opacity

            // Mass Thresholds
            ASTEROID_MASS_LIMIT: 5,
            PLANET_MASS_LIMIT: 20,
            STAR_MASS_LIMIT: 80,
            BLACK_HOLE_MASS: 80,   // Threshold for becoming a Black Hole (High!)
            SUPERNOVA_MASS: 250,   // Threshold for explosion (Rebirth)

            // Interaction
            MIN_MASS: 1,           // Allow smaller inputs for asteroids
            MAX_MASS: 100,         // Allow larger inputs for stars

            DENSITY: 0.6,          // Radius = (mass/density)^0.5
            LAUNCH_POWER: 0.05,    // Launch velocity multiplier

            COLORS: {
                ASTEROID: ['#888888', '#aaaaaa', '#776655', '#998877'],
                PLANET: ['#4da6ff', '#ff6b6b', '#6bff95', '#e0dfd5', '#ff9f43'],
                STAR: ['#a0c4ff', '#b9fbc0', '#fbf8cc', '#ffcfd2', '#f1c0e8', '#cfbaf0', '#90dbf4']
            }
        };

        const canvas = document.getElementById('cosmos');
        const ctx = canvas.getContext('2d', { alpha: false });

        let width, height;
        let stars = [];
        let particles = [];
        let isPaused = false;
        let isImploding = false; // New state for reset animation
        let flashIntensity = 0; // Screen flash for Supernova

        // Viewport transformation
        const view = {
            x: 0,
            y: 0,
            scale: 1.0,
            targetScale: 1.0
        };

        // User Input State
        const mouse = {
            x: 0, y: 0,           // Current screen pos
            startX: 0, startY: 0, // Drag start screen pos
            isDraggingLeft: false,
            isDraggingRight: false,
            dragStartTime: 0
        };

        /* =========================================
           INIT & RESIZE
           ========================================= */
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            // Fill background initially
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, width, height);
        }
        window.addEventListener('resize', resize);
        resize();

        function reset() {
            // Trigger Implosion instead of instant clear
            if (stars.length === 0 && particles.length === 0) return; // Already empty
            isImploding = true;
        }
        document.getElementById('resetBtn').addEventListener('click', reset);

        function generateGalaxy() {
            reset(); // Clear first

            // 1. Central Supermassive Black Hole
            // Mass needs to be high enough to hold galaxy, but not instant-kill everything if orbit is far
            let centerMass = 400;
            let bh = new Star(0, 0, 0, 0, centerMass);
            stars.push(bh);

            // 2. Spawn Stars/Planets
            let count = 200;
            let minDist = bh.radius * 3; // Safe zone
            let maxDist = Math.min(width, height) * 1.5;

            for (let i = 0; i < count; i++) {
                let angle = Math.random() * Math.PI * 2;
                // Spiral distribution: more stars closer to center, but spread out
                let dist = minDist + (maxDist - minDist) * Math.pow(Math.random(), 2); // Bias towards center? No, let's try random
                // Actually uniform disk is better for physics stability visualization usually
                dist = minDist + Math.random() * (maxDist - minDist);

                let x = Math.cos(angle) * dist;
                let y = Math.sin(angle) * dist;

                // Orbital Velocity: v = sqrt(GM/r) for circular orbit
                // We need relative velocity to the BH (which is static 0,0)
                // Tangent vector: (-sin(angle), cos(angle))
                let velocity = Math.sqrt(CONFIG.G * centerMass / dist);

                let vx = -Math.sin(angle) * velocity;
                let vy = Math.cos(angle) * velocity;

                // Random Mass: Mostly planets/asteroids, some stars
                let mass;
                let r = Math.random();
                if (r < 0.6) mass = CONFIG.MIN_MASS + Math.random() * 3; // Asteroid
                else if (r < 0.9) mass = CONFIG.ASTEROID_MASS_LIMIT + Math.random() * 10; // Planet
                else mass = CONFIG.PLANET_MASS_LIMIT + Math.random() * 10; // Small Star

                stars.push(new Star(x, y, vx, vy, mass));
            }

            // Adjust view to see whole galaxy
            view.targetScale = 0.4;
        }
        document.getElementById('galaxyBtn').addEventListener('click', generateGalaxy);

        /* =========================================
           CLASSES
           ========================================= */
        class Star {
            constructor(x, y, vx, vy, mass) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.mass = mass;

                // Rotation
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.1;

                this.updateProperties();

                // Procedural Features Generation
                this.features = {
                    seed: Math.random(),
                    typeVariant: Math.random(), // 0-1 to pick sub-types (e.g. gas giant vs rocky)
                    ring: Math.random() > 0.8, // 20% chance of ring for planets
                    ringColor: 'rgba(255,255,255,0.3)',
                    ringRadius: 1.5 + Math.random(),
                    craters: [],
                    stripes: []
                };

                // Generate specific features based on type
                if (this.features.typeVariant > 0.5) { // Gas Giant Stripes
                    let numStripes = 3 + Math.floor(Math.random() * 4);
                    for (let i = 0; i < numStripes; i++) {
                        this.features.stripes.push({
                            y: (Math.random() - 0.5) * 0.8, // relative Y position
                            height: 0.1 + Math.random() * 0.2, // relative height
                            color: 'rgba(0,0,0,' + (0.1 + Math.random() * 0.2) + ')'
                        });
                    }
                } else { // Rocky Craters
                    let numCraters = 2 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < numCraters; i++) {
                        this.features.craters.push({
                            x: (Math.random() - 0.5) * 0.6,
                            y: (Math.random() - 0.5) * 0.6,
                            r: 0.1 + Math.random() * 0.15
                        });
                    }
                }

                // Solar Flares (for Stars)
                if (this.type === 'STAR') {
                    this.features.flares = [];
                    let numFlares = 3 + Math.floor(Math.random() * 4);
                    for (let i = 0; i < numFlares; i++) {
                        this.features.flares.push({
                            angle: (Math.PI * 2 * i) / numFlares,
                            length: this.radius * (0.5 + Math.random() * 0.5),
                            width: this.radius * 0.2,
                            speed: 0.5 + Math.random(),
                            phase: Math.random() * Math.PI
                        });
                    }
                }

                // Asteroid Shape (Jagged Polygon)
                if (this.type === 'ASTEROID') {
                    this.features.vertices = [];
                    let numVerts = 5 + Math.floor(Math.random() * 4);
                    for (let i = 0; i < numVerts; i++) {
                        let angle = (i / numVerts) * Math.PI * 2;
                        let r = 0.8 + Math.random() * 0.4; // Radius variance
                        this.features.vertices.push({
                            x: Math.cos(angle) * r,
                            y: Math.sin(angle) * r
                        });
                    }
                }

                // Initial Color Assignment if not set
                if (!this.color) {
                    if (this.type === 'BLACK_HOLE') {
                        this.color = '#000000';
                        this.glowColor = '#330066';
                    } else if (this.type === 'STAR') {
                        this.color = CONFIG.COLORS.STAR[Math.floor(Math.random() * CONFIG.COLORS.STAR.length)];
                    } else if (this.type === 'PLANET') {
                        this.color = CONFIG.COLORS.PLANET[Math.floor(Math.random() * CONFIG.COLORS.PLANET.length)];
                    } else { // ASTEROID
                        this.color = CONFIG.COLORS.ASTEROID[Math.floor(Math.random() * CONFIG.COLORS.ASTEROID.length)];
                    }
                }
            }

            updateProperties() {
                // Determine Type
                if (this.mass >= CONFIG.BLACK_HOLE_MASS) {
                    this.type = 'BLACK_HOLE';
                } else if (this.mass > CONFIG.PLANET_MASS_LIMIT) {
                    this.type = 'STAR';
                } else if (this.mass > CONFIG.ASTEROID_MASS_LIMIT) {
                    this.type = 'PLANET';
                } else {
                    this.type = 'ASTEROID';
                }

                // Radius Check
                let density = CONFIG.DENSITY;
                if (this.type === 'BLACK_HOLE') density *= 3; // Dense
                if (this.type === 'PLANET') density *= 1.5;   // Rocky planets are dense-ish
                this.radius = Math.sqrt(this.mass / density);
                this.isBlackHole = (this.type === 'BLACK_HOLE'); // Keep for compatibility
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.rotation += this.rotationSpeed;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);


                if (this.type === 'BLACK_HOLE') {
                    // Pulsating Accretion Disk - Better
                    let pulse = 1.0 + Math.sin(Date.now() * 0.005) * 0.1;

                    // Outer Glow
                    ctx.shadowBlur = this.radius * 4 * pulse;
                    ctx.shadowColor = 'rgba(120, 50, 255, 0.8)';

                    // Accretion Disk (Spiral)
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * 1.5, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(50, 0, 100, 0.5)';
                    ctx.fill();

                    // Event Horizon (Black)
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#000';
                    ctx.shadowBlur = 0; // Black center has no glow itself
                    ctx.fill();

                    // Photon Ring (White outline)
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(200, 200, 255, 0.8)';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                } else if (this.type === 'STAR') {
                    // STAR: Glowing Corona
                    let pulse = 1.0 + Math.sin(Date.now() * 0.01 + this.features.seed * 10) * 0.05;

                    // Corona Layer
                    ctx.globalAlpha = 0.4;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * (1.2 + pulse), 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    ctx.globalAlpha = 1.0;

                    // Core
                    ctx.shadowBlur = this.radius * 2;
                    ctx.shadowColor = this.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#fff'; // Bright core
                    ctx.fill();

                    // Tint over core
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.globalAlpha = 0.8;
                    ctx.fill();
                    ctx.globalAlpha = 1.0;

                    // Solar Flares
                    if (this.features.flares) {
                        ctx.save();
                        for (let f of this.features.flares) {
                            let angle = f.angle + (Date.now() * f.speed * 0.001);
                            let r = this.radius * (1.0 + Math.sin(Date.now() * 0.005 + f.phase) * 0.1);

                            ctx.translate(Math.cos(angle) * r, Math.sin(angle) * r);
                            ctx.rotate(angle + Math.PI / 2);

                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.quadraticCurveTo(f.width, -f.length * 0.5, 0, -f.length);
                            ctx.quadraticCurveTo(-f.width, -f.length * 0.5, 0, 0);
                            ctx.fillStyle = this.color;
                            ctx.globalAlpha = 0.6;
                            ctx.fill();

                            ctx.rotate(-(angle + Math.PI / 2));
                            ctx.translate(-Math.cos(angle) * r, -Math.sin(angle) * r);
                        }
                        ctx.restore();
                    }

                    // Diffraction Spikes (Lens Flare) for Massive Stars
                    if (this.mass > 50) {
                        ctx.save();
                        ctx.globalCompositeOperation = 'screen'; // Additive blending for light
                        ctx.rotate(Date.now() * 0.0001); // Very slow rotation
                        let spikeLen = this.radius * 4;
                        let spikeW = this.radius * 0.2;

                        ctx.fillStyle = this.color;
                        ctx.globalAlpha = 0.3;

                        // Vertical
                        ctx.beginPath();
                        ctx.moveTo(0, -spikeLen);
                        ctx.quadraticCurveTo(spikeW, 0, 0, spikeLen);
                        ctx.quadraticCurveTo(-spikeW, 0, 0, -spikeLen);
                        ctx.fill();

                        // Horizontal
                        ctx.beginPath();
                        ctx.moveTo(-spikeLen, 0);
                        ctx.quadraticCurveTo(0, spikeW, spikeLen, 0);
                        ctx.quadraticCurveTo(0, -spikeW, -spikeLen, 0);
                        ctx.fill();

                        ctx.restore();
                    }

                } else if (this.type === 'PLANET') {
                    ctx.rotate(this.rotation);

                    // Base Body
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.shadowBlur = 0;
                    ctx.fill();

                    // Clip to circle for details
                    ctx.save();
                    ctx.clip();

                    // Details: Stripes or Craters
                    if (this.features.typeVariant > 0.5) {
                        // Stripes
                        for (let s of this.features.stripes) {
                            ctx.fillStyle = s.color;
                            let yPos = s.y * this.radius;
                            let h = s.height * this.radius;
                            ctx.fillRect(-this.radius, yPos, this.radius * 2, h);
                        }
                    } else {
                        // Craters
                        ctx.fillStyle = 'rgba(0,0,0,0.2)';
                        for (let c of this.features.craters) {
                            ctx.beginPath();
                            ctx.arc(c.x * this.radius, c.y * this.radius, c.r * this.radius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Atmosphere/Shadow Gradient (3D look)
                    let grad = ctx.createRadialGradient(-this.radius * 0.3, -this.radius * 0.3, this.radius * 0.2, 0, 0, this.radius);
                    grad.addColorStop(0, 'rgba(255,255,255,0.2)');
                    grad.addColorStop(1, 'rgba(0,0,0,0.4)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore(); // End Clip

                    // Ring?
                    if (this.features.ring && this.type === 'PLANET') {
                        ctx.beginPath();
                        ctx.ellipse(0, 0, this.radius * 2.0, this.radius * 0.4, 0, 0, Math.PI * 2);
                        ctx.strokeStyle = this.features.ringColor;
                        ctx.lineWidth = this.radius * 0.2;
                        ctx.stroke();
                    }

                } else {
                    // ASTEROID: Jagged Polygon
                    ctx.rotate(this.rotation);
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = this.color;

                    ctx.beginPath();
                    if (this.features.vertices && this.features.vertices.length > 0) {
                        let v0 = this.features.vertices[0];
                        ctx.moveTo(v0.x * this.radius, v0.y * this.radius);
                        for (let k = 1; k < this.features.vertices.length; k++) {
                            let v = this.features.vertices[k];
                            ctx.lineTo(v.x * this.radius, v.y * this.radius);
                        }
                    } else {
                        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    }
                    ctx.closePath();
                    ctx.fill();

                    // Rough shading
                    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                ctx.shadowBlur = 0; // Reset
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color, isSucked = false, target = null) {
                this.x = x;
                this.y = y;
                this.color = color;

                if (isSucked && target) {
                    this.isSucked = true;
                    this.target = target;
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = (Math.random() - 0.5) * 2;
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 3; // Slightly faster for explosion
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                }

                this.life = 1.0;
                this.decay = 0.01 + Math.random() * 0.03;
            }

            update() {
                if (this.isSucked && this.target) {
                    // Accelerate towards black hole
                    let dx = this.target.x - this.x;
                    let dy = this.target.y - this.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);

                    this.vx += dx * 0.05;
                    this.vy += dy * 0.05;
                    this.x += this.vx;
                    this.y += this.vy;

                    // Fade faster when close
                    if (dist < this.target.radius) {
                        this.life = 0;
                    }
                } else {
                    this.x += this.vx;
                    this.y += this.vy;
                }
                this.life -= this.decay;
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, 2, 2);
                ctx.globalAlpha = 1.0;
            }
        }

        /* =========================================
           PHYSICS
           ========================================= */
        function updatePhysics() {
            // Check for Implosion Reset
            if (isImploding) {
                updateImplosion();
                return; // Skip normal physics
            }

            // Check for Implosion Reset
            if (isImploding) {
                updateImplosion();
                return; // Skip normal physics
            }

            // Check for Supernova
            for (let i = stars.length - 1; i >= 0; i--) {
                if (stars[i].mass >= CONFIG.SUPERNOVA_MASS) {
                    triggerSupernova(i);
                    // Star is removed in function, continue loop safely
                    continue;
                }
            }

            // N-body integration
            for (let i = 0; i < stars.length; i++) {
                let s1 = stars[i];
                for (let j = i + 1; j < stars.length; j++) {
                    let s2 = stars[j];

                    let dx = s2.x - s1.x;
                    let dy = s2.y - s1.y;
                    let distSq = dx * dx + dy * dy;
                    let dist = Math.sqrt(distSq);

                    // Collision Logic
                    if (dist < s1.radius + s2.radius) {
                        // Check Black Hole Interaction
                        if (s1.isBlackHole || s2.isBlackHole) {
                            consumeStar(i, j); // Black Hole eats Star (or smaller BH)
                        } else {
                            mergeStars(i, j); // Normal merge
                        }
                        j--; // Adjustment
                        continue;
                    }

                    // Gravity Force
                    if (dist > 5) {
                        let force = (CONFIG.G * s1.mass * s2.mass) / distSq;
                        let ax = force * (dx / dist);
                        let ay = force * (dy / dist);

                        s1.vx += ax / s1.mass;
                        s1.vy += ay / s1.mass;
                        s2.vx -= ax / s2.mass;
                        s2.vy -= ay / s2.mass;
                    }
                }
            }

            // Update positions
            for (let s of stars) {
                s.update();
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (particles[i].life <= 0) particles.splice(i, 1);
            }
        }

        function triggerSupernova(index) {
            let star = stars[index];

            // 1. Screen Flash
            flashIntensity = 1.0;

            // 2. Explosion Particles
            for (let k = 0; k < 100; k++) {
                particles.push(new Particle(star.x, star.y, '#ffffff'));
                particles.push(new Particle(star.x, star.y, '#aaaaff'));
            }

            // 3. Rebirth (Scatter small stars)
            let newStarsCount = 8 + Math.floor(Math.random() * 5);
            for (let k = 0; k < newStarsCount; k++) {
                let angle = (Math.PI * 2 * k) / newStarsCount;
                let speed = 2 + Math.random() * 3;

                let vx = Math.cos(angle) * speed + star.vx * 0.5; // Inherit some momentum
                let vy = Math.sin(angle) * speed + star.vy * 0.5;
                let mass = CONFIG.MIN_MASS + Math.random() * 5; // Small new stars

                stars.push(new Star(star.x + Math.cos(angle) * star.radius * 2, star.y + Math.sin(angle) * star.radius * 2, vx, vy, mass));
            }

            // Remove the Black Hole
            stars.splice(index, 1);

            // Console log for fun
            console.log("SUPERNOVA!");
        }

        // Logic when a Black Hole is involved
        function consumeStar(i, j) {
            let s1 = stars[i];
            let s2 = stars[j];

            // Determine predator and prey
            let predator, prey;

            // If both are BH, larger one eats smaller
            if (s1.isBlackHole && s2.isBlackHole) {
                if (s1.mass >= s2.mass) { predator = s1; prey = s2; }
                else { predator = s2; prey = s1; }
            }
            // If only one is BH
            else if (s1.isBlackHole) { predator = s1; prey = s2; }
            else { predator = s2; prey = s1; }

            // Predator grows
            predator.mass += prey.mass;

            // Conservation of momentum (Predator absorbs prey's momentum slightly)
            // But BH are heavy, so velocity change is small
            let totalMass = predator.mass; // Already added prey mass
            // Current momentum of predator before adding prey mass was (predator.mass - prey.mass) * v
            // This is simplified: just blend velocities based on mass ratio
            // V_new = (M_pred_old * V_pred + M_prey * V_prey) / M_new
            let m_old = predator.mass - prey.mass;
            predator.vx = (m_old * predator.vx + prey.mass * prey.vx) / predator.mass;
            predator.vy = (m_old * predator.vy + prey.mass * prey.vy) / predator.mass;

            // Update radius/type
            predator.updateProperties();

            // Sucking particles effect
            for (let k = 0; k < 15; k++) {
                // Particles start at prey position, get sucked into predator
                particles.push(new Particle(
                    prey.x + (Math.random() - 0.5) * prey.radius,
                    prey.y + (Math.random() - 0.5) * prey.radius,
                    prey.color,
                    true,
                    predator
                ));
            }

            // Remove prey
            // We need to find the correct index to splice
            // i and j are original indices.
            // If s1 is prey, remove i. If s2 is prey, remove j.
            if (prey === s1) stars.splice(i, 1);
            else stars.splice(j, 1);
        }

        // Logic for normal stars
        function mergeStars(i, j) {
            let s1 = stars[i];
            let s2 = stars[j];

            let totalMass = s1.mass + s2.mass;
            let newVx = (s1.mass * s1.vx + s2.mass * s2.vx) / totalMass;
            let newVy = (s1.mass * s1.vy + s2.mass * s2.vy) / totalMass;

            let newX = (s1.x * s1.mass + s2.x * s2.mass) / totalMass;
            let newY = (s1.y * s1.mass + s2.y * s2.mass) / totalMass;

            // Remove old stars
            stars.splice(Math.max(i, j), 1);
            stars.splice(Math.min(i, j), 1);

            let newStar = new Star(newX, newY, newVx, newVy, totalMass);
            stars.push(newStar);

            // Explosion effect
            for (let k = 0; k < 8; k++) {
                particles.push(new Particle(newX, newY, newStar.color));
            }
        }


        function updateImplosion() {
            // Pull everything to center violently
            let centerX = 0;
            let centerY = 0;

            for (let i = stars.length - 1; i >= 0; i--) {
                let s = stars[i];
                let dx = centerX - s.x;
                let dy = centerY - s.y;
                let dist = Math.sqrt(dx * dx + dy * dy);

                // Strong Pull
                s.x += dx * 0.1;
                s.y += dy * 0.1;

                // Shrink
                s.radius *= 0.9;

                // Remove if close/small
                if (dist < 10 || s.radius < 0.5) {
                    stars.splice(i, 1);
                }
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                let dx = centerX - p.x;
                let dy = centerY - p.y;
                p.x += dx * 0.15;
                p.y += dy * 0.15;
                if (Math.abs(dx) < 10 && Math.abs(dy) < 10) particles.splice(i, 1);
            }

            // End condition
            if (stars.length === 0 && particles.length === 0) {
                isImploding = false;
                view.targetScale = 1.0;
                view.x = 0;
                view.y = 0;
            }
        }

        /* =========================================
           RENDERING
           ========================================= */
        function screenToWorld(sx, sy) {
            let centeredX = sx - width / 2;
            let centeredY = sy - height / 2;
            return {
                x: (centeredX / view.scale) - view.x,
                y: (centeredY / view.scale) - view.y
            };
        }

        function render() {
            // Smooth zoom interpolation
            view.scale += (view.targetScale - view.scale) * 0.1;

            // BACKGROUND with distortion hint for Black Holes?
            // Simple approach: Clear with trail fade
            ctx.fillStyle = `rgba(5, 5, 16, ${CONFIG.TRAIL_FADE})`;
            ctx.fillRect(0, 0, width, height);

            ctx.save();

            // Apply Camera Transform
            ctx.translate(width / 2, height / 2);
            ctx.scale(view.scale, view.scale);
            ctx.translate(view.x, view.y);

            // Draw Black Holes Layer First? No, standard Z-order (draw loop) is fine for 2D.
            // Just iterate.
            for (let s of stars) s.draw(ctx);
            for (let p of particles) p.draw(ctx);

            // Draw Launch Prediction
            if (mouse.isDraggingLeft) {
                let startWorld = screenToWorld(mouse.startX, mouse.startY);
                let currentWorld = screenToWorld(mouse.x, mouse.y);

                // Prediction Line
                // Launch Velocity
                let dx = mouse.startX - mouse.x;
                let dy = mouse.startY - mouse.y;
                let vx = dx * CONFIG.LAUNCH_POWER / view.scale;
                let vy = dy * CONFIG.LAUNCH_POWER / view.scale;

                // Preview Mass Logic (duplicated from mouseup for prediction)
                let duration = (Date.now() - mouse.dragStartTime) / 1000;
                let mass;
                if (duration < 0.5) {
                    mass = CONFIG.MIN_MASS + (CONFIG.ASTEROID_MASS_LIMIT - CONFIG.MIN_MASS) * (duration / 0.5);
                } else if (duration < 2.0) {
                    mass = CONFIG.ASTEROID_MASS_LIMIT + (CONFIG.PLANET_MASS_LIMIT - CONFIG.ASTEROID_MASS_LIMIT) * ((duration - 0.5) / 1.5);
                } else {
                    mass = CONFIG.PLANET_MASS_LIMIT + (CONFIG.STAR_MASS_LIMIT - CONFIG.PLANET_MASS_LIMIT) * Math.min((duration - 2.0) / 3.0, 1);
                }

                // Calculate Trajectory
                let path = predictTrajectory(startWorld.x, startWorld.y, vx, vy, mass);

                // Draw Computed Trajectory
                ctx.beginPath();
                ctx.moveTo(startWorld.x, startWorld.y);
                for (let pt of path) {
                    ctx.lineTo(pt.x, pt.y);
                }
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.setLineDash([5, 5]);
                ctx.stroke();

                // Vector
                let vecX = dx * CONFIG.LAUNCH_POWER * 20;
                let vecY = dy * CONFIG.LAUNCH_POWER * 20;

                ctx.beginPath();
                ctx.moveTo(startWorld.x, startWorld.y);
                ctx.lineTo(startWorld.x + vecX / view.scale, startWorld.y + vecY / view.scale);
                ctx.strokeStyle = 'rgba(100, 255, 150, 0.8)';
                ctx.setLineDash([]);
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.lineWidth = 1;

                // Determine density for preview radius
                let density = CONFIG.DENSITY;
                if (mass > CONFIG.PLANET_MASS_LIMIT) density = CONFIG.DENSITY; // Star
                else if (mass > CONFIG.ASTEROID_MASS_LIMIT) density = CONFIG.DENSITY * 1.5; // Planet

                let previewRadius = Math.sqrt(mass / density);

                ctx.beginPath();
                ctx.arc(startWorld.x, startWorld.y, previewRadius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.stroke();
            }

            ctx.restore();

            // Screen Flash for Supernova
            if (flashIntensity > 0.01) {
                ctx.fillStyle = `rgba(255, 255, 255, ${flashIntensity})`;
                ctx.fillRect(0, 0, width, height);
                flashIntensity *= 0.90; // Fade out
            } else {
                flashIntensity = 0;
            }

            updatePhysics();
            requestAnimationFrame(render);
        }

        /* =========================================
           INPUT HANDLING
           ========================================= */
        canvas.addEventListener('mousedown', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;

            if (e.button === 0) { // Left Click
                mouse.isDraggingLeft = true;
                mouse.startX = e.clientX;
                mouse.startY = e.clientY;
                mouse.dragStartTime = Date.now();
            }
            else if (e.button === 2) { // Right Click
                mouse.isDraggingRight = true;
                mouse.startX = e.clientX;
                mouse.startY = e.clientY;
            }
        });

        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;

            if (mouse.isDraggingRight) {
                let dx = e.clientX - mouse.startX;
                let dy = e.clientY - mouse.startY;
                view.x += dx / view.scale;
                view.y += dy / view.scale;
                mouse.startX = e.clientX;
                mouse.startY = e.clientY;
            }
        });

        window.addEventListener('mouseup', e => {
            if (mouse.isDraggingLeft && e.button === 0) {
                let dx = mouse.startX - e.clientX;
                let dy = mouse.startY - e.clientY;

                let duration = (Date.now() - mouse.dragStartTime) / 1000;

                let mass;
                if (duration < 0.5) {
                    mass = CONFIG.MIN_MASS + (CONFIG.ASTEROID_MASS_LIMIT - CONFIG.MIN_MASS) * (duration / 0.5);
                } else if (duration < 2.0) {
                    mass = CONFIG.ASTEROID_MASS_LIMIT + (CONFIG.PLANET_MASS_LIMIT - CONFIG.ASTEROID_MASS_LIMIT) * ((duration - 0.5) / 1.5);
                } else {
                    mass = CONFIG.PLANET_MASS_LIMIT + (CONFIG.STAR_MASS_LIMIT - CONFIG.PLANET_MASS_LIMIT) * Math.min((duration - 2.0) / 3.0, 1);
                }

                let worldPos = screenToWorld(mouse.startX, mouse.startY);

                let vx = dx * CONFIG.LAUNCH_POWER / view.scale;
                let vy = dy * CONFIG.LAUNCH_POWER / view.scale;

                stars.push(new Star(worldPos.x, worldPos.y, vx, vy, mass));

                mouse.isDraggingLeft = false;
            }
            if (e.button === 2) {
                mouse.isDraggingRight = false;
            }
        });

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            const zoomSensitivity = 0.001;
            view.targetScale -= e.deltaY * zoomSensitivity * view.targetScale;
            view.targetScale = Math.max(0.1, Math.min(view.targetScale, 10.0));
        }, { passive: false });

        canvas.addEventListener('contextmenu', e => e.preventDefault());

        /* =========================================
           START
           ========================================= */
        function predictTrajectory(startX, startY, vx, vy, mass) {
            let path = [];
            let x = startX;
            let y = startY;
            let pVx = vx;
            let pVy = vy;

            // Simulation steps (e.g., 60 frames = 1 second)
            let steps = 120;

            for (let k = 0; k < steps; k++) {
                path.push({ x, y });

                // Calculate forces from existing stars (Simple Gravity)
                // Optimisation: Only calculate for massive bodies if too many starts
                let relevantStars = stars;
                if (stars.length > 50) {
                    // Filter only big stars/black holes for performance? 
                    // Or just skip prediction if too many. Let's try full N-body for now, but limited steps.
                    // 120 * 200 = 24000 checks, might be heavy.
                }

                for (let s of stars) {
                    let dx = s.x - x;
                    let dy = s.y - y;
                    let distSq = dx * dx + dy * dy;
                    let dist = Math.sqrt(distSq);

                    if (dist > s.radius + 5) { // Avoid division by zero and sticking
                        let force = (CONFIG.G * mass * s.mass) / distSq;
                        let ax = force * (dx / dist);
                        let ay = force * (dy / dist);
                        pVx += ax / mass;
                        pVy += ay / mass;
                    }
                }

                x += pVx;
                y += pVy;
            }
            return path;
        }

        // Create initial scenario: One normal star and one near-BH threshold star to test evolution easily?
        // Let's just do standard random
        for (let i = 0; i < 5; i++) {
            stars.push(new Star(
                (Math.random() - 0.5) * 300,
                (Math.random() - 0.5) * 300,
                (Math.random() - 0.5) * 1,
                (Math.random() - 0.5) * 1,
                Math.random() * 10 + 5
            ));
        }

        render();

    </script>
</body>

</html>